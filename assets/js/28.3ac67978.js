(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{344:function(e,v,t){"use strict";t.r(v);var a=t(3),_=Object(a.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"吾不该止步于此-刷够多少题才算够系列之vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#吾不该止步于此-刷够多少题才算够系列之vue"}},[e._v("#")]),e._v(" 吾不该止步于此！刷够多少题才算够系列之Vue")]),e._v(" "),v("h2",{attrs:{id:"vue区别原生"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue区别原生"}},[e._v("#")]),e._v(" vue区别原生")]),e._v(" "),v("ul",[v("li",[e._v("首先vue是一款轻量、易上手的前端框架")]),e._v(" "),v("li",[e._v("支持组件化，简化代码，能够提升开发效率")]),e._v(" "),v("li",[e._v("增加虚拟dom，数据使用双向绑定，数据和dom分离")]),e._v(" "),v("li",[e._v("使用单页面开发，页面局部刷新，只请求该页面的数据和dom，加载速度相对较快")]),e._v(" "),v("li",[e._v("MVVM思想\n"),v("ul",[v("li",[e._v("本质是模型-视图-视图模型")]),e._v(" "),v("li",[e._v("模型表示后端数据，视图表示页面，视图模型表示将数据转化成视图的方式")]),e._v(" "),v("li",[e._v("这种方式也是vue的核心，也就是数据的双向绑定，能够实现数据和视图的同步更新")])])])]),e._v(" "),v("h2",{attrs:{id:"vue路由模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue路由模式"}},[e._v("#")]),e._v(" vue路由模式")]),e._v(" "),v("ul",[v("li",[e._v("vue路由模式有hash和history模式")]),e._v(" "),v("li",[e._v("两种模式在url显示上，hash有#,并且改变#后边的内容，不会触发请求；history没有#,改变url会触发请求")]),e._v(" "),v("li",[e._v("在实现上，hash通过监听hashchange事件来进行路由切换；history是通过监听pushstate进行路由切换")]),e._v(" "),v("li",[e._v("兼容性上，history兼容性差一点")]),e._v(" "),v("li",[e._v("vue项目路由配置上，通过mode属性进行配置，另外，history一般部署到nginx时，刷新会报404,所以需要配置刷新进行重定向")]),e._v(" "),v("li",[e._v("history需要配置base: process.env.BASE_URL")])]),e._v(" "),v("h2",{attrs:{id:"vue基于axios请求封装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue基于axios请求封装"}},[e._v("#")]),e._v(" vue基于axios请求封装")]),e._v(" "),v("ul",[v("li",[e._v("参造ruoyi框架")]),e._v(" "),v("li",[e._v("首先创建一个工具类，request.js文件")]),e._v(" "),v("li",[e._v("在这个文件中，导入axios依赖，利用axios.create({})创建一个请求对象,它接收一个对象参数，可以设置请求基本路径baseURL以及请求超时时间timeout，再将请求对象导出")]),e._v(" "),v("li",[e._v("之后在模块的请求接口中，导入request，就可以使用这个request对象，传api路径url以及请求方法methods和参数之后并返回")]),e._v(" "),v("li",[e._v("实现api接口的按需导入")]),e._v(" "),v("li",[e._v("拦截器可以通过axios.interceptors.request/response")])]),e._v(" "),v("h2",{attrs:{id:"vuex中如何分模块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex中如何分模块"}},[e._v("#")]),e._v(" vuex中如何分模块")]),e._v(" "),v("ul",[v("li",[e._v("之所以分模块，是为了模块分明，高耦合利于项目维护")]),e._v(" "),v("li",[e._v("在store文件夹下新建mudules，该文件夹下保存各个模块的状态，可以通过mapState获取模块状态值")]),e._v(" "),v("li",[e._v("mudules下存放每个模块的文件，一个模块一个文件")]),e._v(" "),v("li",[e._v("在store文件夹下新建getter.js，该文件夹下保存需要映射出去的状态值，可以通过mapGetters获取getter值")]),e._v(" "),v("li",[e._v("在store文件夹下有个index.js,负责实例化store对象并且设置getter、module")])]),e._v(" "),v("h2",{attrs:{id:"vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),v("ul",[v("li",[e._v("Vue生命周期是从Vue实例创建到销毁的过程，一般有beforeCreate、create、beforeMount、mounted、beforeUpdate、updated、beforeDestroyed、destroyed")]),e._v(" "),v("li",[e._v("最早访问到data和method，一般请求数据是在create中使用，此时dom节点还未挂载，所以不能操作dom")]),e._v(" "),v("li",[e._v("mounted表示节点已经挂载完毕，所以最早访问到dom节点发生在mounted")]),e._v(" "),v("li",[e._v("用keep-live包裹的组件，会有activated、deactivated两个生命周期，表示组件激活和离开组件时使用")])]),e._v(" "),v("h2",{attrs:{id:"vue中data为什么是一个函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中data为什么是一个函数"}},[e._v("#")]),e._v(" vue中data为什么是一个函数")]),e._v(" "),v("ul",[v("li",[e._v("每次vue组件挂载时会通过Vue.extend实现一个子类")]),e._v(" "),v("li",[e._v("组件可能会多次调用，每次调用会执行data,返回一个全新的对象，这样可以避免数据污染")]),e._v(" "),v("li",[e._v("如果是对象的话，会共用一个引用地址，数据修改会造成源对象数据被修改")])]),e._v(" "),v("h2",{attrs:{id:"vue响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式原理"}},[e._v("#")]),e._v(" vue响应式原理")]),e._v(" "),v("ul",[v("li",[e._v("利用Object.defineProperty对数据进行处理")]),e._v(" "),v("li",[e._v("对于数组，会重写数组方法，push、pop、shift、unshfit、sort、reverse")]),e._v(" "),v("li",[e._v("对于对象，会递归遍历对象属性进行Object.defineProperty监听")])]),e._v(" "),v("h2",{attrs:{id:"vue中diff算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中diff算法"}},[e._v("#")]),e._v(" vue中diff算法")]),e._v(" "),v("ul",[v("li",[e._v("比较新旧虚拟dom来进行最小化更新\n"),v("ul",[v("li",[e._v("虚拟dom是真实dom抽象出来的一个vnode对象，包含一些样式、子节点、标签等属性")]),e._v(" "),v("li",[e._v("抽象原本dom节点渲染过程，让节点进行最小化更新，提高页面渲染速度")])])]),e._v(" "),v("li",[e._v("使用的是深度优先算法，进行比较dom\n"),v("ul",[v("li",[e._v("在path函数中，比较新旧虚拟dom")]),e._v(" "),v("li",[e._v("如果只有新节点，那么就创建节点，如果只有旧节点，那么就删除节点")]),e._v(" "),v("li",[e._v("如果新旧节点都有，需要利用key值判断新旧节点是否一致，一致调用pathVNode方法，不一致，就创建新节点，删除旧节点")]),e._v(" "),v("li",[e._v("在pathVNode方法中也做了判断，除了重复操作，不一样的是比较子节点，利用新旧节点的头尾指针进行循环并且向中间靠拢，进行判断，重复path操作")])])])]),e._v(" "),v("h2",{attrs:{id:"在组件中修改props的值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在组件中修改props的值"}},[e._v("#")]),e._v(" 在组件中修改props的值")]),e._v(" "),v("ul",[v("li",[e._v("如果是基本数据类型会报错")]),e._v(" "),v("li",[e._v("如果是引用类型的话，改变引用类型属性不会报错，但是直接修改引用对象本身会报错")])]),e._v(" "),v("h2",{attrs:{id:"nexttick的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的原理"}},[e._v("#")]),e._v(" nextTick的原理")]),e._v(" "),v("ul",[v("li",[e._v("在下次 DOM 更新循环结束之后执行延迟回调\n"),v("ul",[v("li",[e._v("将回调函数放入callback中，等待执行")]),e._v(" "),v("li",[e._v("将执行函数放入微任务或者宏任务当中")]),e._v(" "),v("li",[e._v("事件循环循环到微任务或者宏任务时，依次执行callback中的回调函数")]),e._v(" "),v("li",[e._v("会根据当前原生支持什么函数，Promise优先级更高，再然后是mutationObserve->setImmediate->setTimeout")])])])]),e._v(" "),v("h2",{attrs:{id:"vue钩子函数使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue钩子函数使用场景"}},[e._v("#")]),e._v(" Vue钩子函数使用场景")]),e._v(" "),v("ul",[v("li",[e._v("watch表示监听一个数据发生的变化，可以通过deep属性进行对象的深度监听，通过immediate属性可以在组件加载时触发，可以进行异步操作，没有缓存，一般用在一个数据发生变化，需要执行相应操作时")]),e._v(" "),v("li",[e._v("computed具有缓存，只有依赖的数据发生改变才会触发")]),e._v(" "),v("li",[e._v("methods不具有缓存，每次页面加载都会执行，一般用作创建函数")])]),e._v(" "),v("h2",{attrs:{id:"watch和computed区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch和computed区别"}},[e._v("#")]),e._v(" watch和computed区别")]),e._v(" "),v("ul",[v("li",[e._v("watch是用来监听data中数据的变化，支持深度监听")]),e._v(" "),v("li",[e._v("computed是由data中存在的已知值计算出结果，该值不在data上，并且不能直接修改")])]),e._v(" "),v("h2",{attrs:{id:"vue组件之间传递参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件之间传递参数"}},[e._v("#")]),e._v(" Vue组件之间传递参数")]),e._v(" "),v("ul",[v("li",[e._v("props")]),e._v(" "),v("li",[e._v("eventBus:$emit/$on")]),e._v(" "),v("li",[e._v("$ref")]),e._v(" "),v("li",[e._v("vuex")]),e._v(" "),v("li",[e._v("路由传参")]),e._v(" "),v("li",[e._v("本地存储\n"),v("em",[e._v("注意：$ref获取的是获取通过ref属性注册过的dom节点，得到的是一个dom节点对象实例，相比原生获取节点性能消耗较少")])])]),e._v(" "),v("h2",{attrs:{id:"this-route和this-router的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this-route和this-router的区别"}},[e._v("#")]),e._v(" this.$route和this.$router的区别")]),e._v(" "),v("ul",[v("li",[e._v("this.$route是当前激活的路由对象，可以解析到url的数据，比如params、name、path")]),e._v(" "),v("li",[e._v("this.$router是VueRouter实例上的属性，可以控制url，比如添加push或者回退back")])]),e._v(" "),v("h2",{attrs:{id:"路由参数区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由参数区别"}},[e._v("#")]),e._v(" 路由参数区别")]),e._v(" "),v("ul",[v("li",[e._v("query\n"),v("ul",[v("li",[e._v("拼接在url上的参数，通过push时需要设置path路径")])])]),e._v(" "),v("li",[e._v("params\n"),v("ul",[v("li",[e._v("是路由的一部分，通过push时需要设置name，并且在url上必须使用参数名设置参数")])])])]),e._v(" "),v("h2",{attrs:{id:"vue状态管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue状态管理"}},[e._v("#")]),e._v(" Vue状态管理")]),e._v(" "),v("ul",[v("li",[e._v("state\n"),v("ul",[v("li",[e._v("保存状态数据")])])]),e._v(" "),v("li",[e._v("getter\n"),v("ul",[v("li",[e._v("状态的计算属性，可以通过mapGetter映射")])])]),e._v(" "),v("li",[e._v("actions\n"),v("ul",[v("li",[e._v("触发的是mutations的方法，而不是更改状态")])])]),e._v(" "),v("li",[e._v("mutations\n"),v("ul",[v("li",[e._v("更改状态的方法")])])]),e._v(" "),v("li",[e._v("module\n"),v("ul",[v("li",[e._v("模块化，通过mapState获取模块状态")])])]),e._v(" "),v("li",[e._v("更改状态方法\n"),v("ul",[v("li",[e._v("通过dispath触发actions方法，属于异步")]),e._v(" "),v("li",[e._v("通过commit触发mutations方法，属于同步")])])])]),e._v(" "),v("h2",{attrs:{id:"vue怎么进行权限控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue怎么进行权限控制"}},[e._v("#")]),e._v(" Vue怎么进行权限控制")]),e._v(" "),v("ul",[v("li",[e._v("对于登录情况，判断用户是否进行登录，未登录跳转到登录页，登录了之后跳到首页，可以利用后端返回token保存，比如local Storage,然后每次请求都会判断是否含有token")]),e._v(" "),v("li",[e._v("对于菜单权限，可以在用户登录时，将该用户具有的路由数据发送给前端，前端拿到数据可以利用addRoutes动态添加到路由表中")]),e._v(" "),v("li",[e._v("对于按钮权限，前端利用vue自定义指令，给每个按钮设置相应的权限指令，在设置指令时可以先拿到用户权限数据，保存到vuex中，在插入节点时，判断当前用户是否具有该权限，否则删除或者禁用按钮")]),e._v(" "),v("li",[e._v("除了这些，主要还是需要后端配合实现")])]),e._v(" "),v("h2",{attrs:{id:"如何调试项目代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何调试项目代码"}},[e._v("#")]),e._v(" 如何调试项目代码")]),e._v(" "),v("ul",[v("li",[e._v("在项目代码中设置debugger，浏览器进行调试")]),e._v(" "),v("li",[e._v('利用vscode的debugger插件，可以在vscode进行调试，需要给代码设置断点，在通过配置launch.json文件，开启调试，另外在vue项目的话需要设置configWebpack.devtool="source-map"')])]),e._v(" "),v("h2",{attrs:{id:"如何实现刷新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何实现刷新"}},[e._v("#")]),e._v(" 如何实现刷新")]),e._v(" "),v("ul",[v("li",[e._v("当前组件\n"),v("ul",[v("li",[e._v("this.$forceUpdate强制重新渲染")]),e._v(" "),v("li",[e._v("v-if")]),e._v(" "),v("li",[e._v("绑定key，更改key")])])]),e._v(" "),v("li",[e._v("当前路由\n"),v("ul",[v("li",[e._v("router.go(0)")])])])]),e._v(" "),v("h2",{attrs:{id:"element-ui和antd-design-vue有什么区别感受"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#element-ui和antd-design-vue有什么区别感受"}},[e._v("#")]),e._v(" Element-ui和Antd-design-vue有什么区别感受")]),e._v(" "),v("ul",[v("li",[e._v("上手难度上，element-ui相对比较简单")]),e._v(" "),v("li",[e._v("组件功能上，element-ui的table组件比较完善，比如拖动表格")]),e._v(" "),v("li",[e._v("element-ui相比Antd-design-vue，可以在前台页面扩展，而Antd-design-vue比较倾向后台管理系统的扩展")])])])}),[],!1,null,null,null);v.default=_.exports}}]);